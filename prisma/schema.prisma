// ─────────────────────────────────────────────────────────────────
// ModelTriage — Prisma Schema
//
// Database: Supabase Postgres (transaction pooler on port 6543)
//
// This schema defines the persistence layer for:
//   1. Routing analytics (RoutingDecision)
//   2. User profiles & roles (UserProfile)
//   3. Usage tracking & monetization (DailyUsage, AnonymousUsage)
//
// Two connection URLs:
//   DATABASE_URL  — Transaction pooler (port 6543, pgbouncer=true)
//                   Used for all runtime queries from the app.
//   DIRECT_URL    — Direct connection (port 5432)
//                   Used only by Prisma Migrate for DDL operations,
//                   since pgbouncer cannot handle migration commands.
//
// Auth: Supabase Auth manages auth.users. A Postgres trigger
// creates a UserProfile row on signup. Prisma manages all
// tables in the public schema.
// ─────────────────────────────────────────────────────────────────

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ─── User Profile ─────────────────────────────────────────────
//
// App-specific user data. The `id` matches auth.users.id from
// Supabase Auth. A database trigger creates this row automatically
// when a new user signs up via Supabase Auth.
//
// Role determines feature access and usage limits.
// stripeCustomerId is reserved for Phase 2 Stripe integration.

model UserProfile {
  id               String   @id // matches Supabase auth.users.id
  role             String   @default("free") // "free" | "pro"
  stripeCustomerId String?  @map("stripe_customer_id")
  createdAt        DateTime @default(now()) @map("created_at")

  dailyUsage DailyUsage[]

  @@map("user_profiles")
}

// ─── Daily Usage ──────────────────────────────────────────────
//
// Tracks per-user, per-day request counts for limit enforcement.
// Uses atomic upsert + increment to prevent race conditions when
// a user fires multiple requests concurrently.
//
// The unique constraint on (userId, date) enables efficient
// upsert: one row per user per day, atomically incremented.

model DailyUsage {
  id     String   @id @default(uuid())
  userId String   @map("user_id")
  date   DateTime @db.Date // truncated to calendar day
  count  Int      @default(0)

  user UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@map("daily_usage")
}

// ─── Anonymous Usage ──────────────────────────────────────────
//
// Tracks lifetime usage for anonymous (not logged in) visitors.
// The fingerprint is a hash of IP + anonymousId to correlate
// requests without storing PII.
//
// This is soft enforcement — a friction nudge toward signup,
// not a security boundary. Determined users can reset localStorage
// or change IP. That's acceptable for Phase 1.

model AnonymousUsage {
  id          String   @id @default(uuid())
  fingerprint String   @unique // hash(IP + anonymousId)
  count       Int      @default(0)
  createdAt   DateTime @default(now()) @map("created_at")

  @@map("anonymous_usage")
}

// ─── Routing Decision ───────────────────────────────────────────
//
// One row per auto-select or compare-mode request.
// Auto-select rows include scoring data; compare rows include
// the diff summary and verdict.
//
// Privacy: promptHash is a SHA-256 of the normalized prompt.
// Raw prompts and model responses are NEVER stored.

model RoutingDecision {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now()) @map("created_at")

  // ── Identity ──────────────────────────────────────────────────
  // Anonymous user identifier (UUID from localStorage).
  // Not linked to any account — just correlates decisions
  // from the same browser session for outcome analysis.
  anonymousId String @map("anonymous_id")

  // Authenticated user ID (nullable). When set, links this
  // decision to a UserProfile for per-user analytics.
  // Null for anonymous requests.
  userId String? @map("user_id")

  // ── Request ───────────────────────────────────────────────────
  // SHA-256 hash of the normalized prompt. Used for deduplication
  // and analytics without storing the raw prompt text.
  promptHash String @map("prompt_hash")

  // Character count of the raw prompt. Used for analytics
  // (complexity correlation, response time scaling) without
  // storing the prompt itself. Privacy-safe.
  promptLength Int? @map("prompt_length")

  // "auto" or "compare" — which mode the user was in.
  mode String // "auto" | "compare"

  // ── Classification (both modes) ─────────────────────────────
  // Output of the deterministic prompt classifier.
  // Populated for both auto-select and compare mode rows.
  taskType    String? @map("task_type")    // code_gen, debug, refactor, etc.
  stakes      String?                       // low, medium, high
  // Input signals as JSON: { hasCode, hasStackTrace, strictFormat, ... }
  inputSignals Json? @map("input_signals")

  // ── Routing ────────────────────────────────────────────────────
  // For auto-select: the actual routing decision.
  // For compare: shadow routing — what the router *would have* chosen.
  selectedModel String? @map("selected_model") // e.g. "claude-sonnet-4-5-20250929"
  routingIntent String? @map("routing_intent") // coding, writing, analysis, vision
  routingCategory String? @map("routing_category") // coding_quick, writing_standard, etc.
  routingConfidence Float? @map("routing_confidence") // 0.0–1.0

  // ── Scoring (both modes) ──────────────────────────────────────
  // For auto-select: scoring for the selected model.
  // For compare: shadow scoring — what the router's pick would have scored.
  // Stored for future calibration of the capability matrix.
  expectedSuccess Int?    @map("expected_success") // 0–100
  confidence      String?                           // "Low", "Medium", "High"
  // Full key factors array as JSON
  keyFactors      Json?   @map("key_factors")

  // ── Performance ───────────────────────────────────────────────
  // Total wall-clock time for the model response(s) in milliseconds.
  // Auto-select: time from model dispatch to stream completion.
  // Compare: total time for all model streams to complete.
  responseTimeMs Int? @map("response_time_ms")

  // ── Compare Mode Fields ───────────────────────────────────────
  // Which models were compared (JSON array of model IDs).
  modelsCompared Json? @map("models_compared") // ["gpt-5.2", "claude-sonnet-4-5-20250929"]
  // Full diff summary as JSON (common ground, key differences, notable gaps).
  diffSummary    Json? @map("diff_summary")
  // One-sentence verdict from the comparison LLM.
  verdict        String?

  // ── Indexes ───────────────────────────────────────────────────
  @@index([anonymousId])
  @@index([userId])
  @@index([mode])
  @@index([selectedModel])
  @@index([taskType])
  @@index([createdAt])

  @@map("routing_decisions")
}
